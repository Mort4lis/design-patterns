from abc import ABC, abstractmethod


class Transport(ABC):
    """
   Абстрактный транспорт объявляет операции, которые должны выполнять все
   конкретные наследники.
   """

    @abstractmethod
    def deliver(self):
        pass


# Конкретные продукты - транспорты

class Truck(Transport):
    def deliver(self):
        print('Доставляю груз с помощью грузовика')


class Ship(Transport):
    def deliver(self):
        print('Доставляю груз с помощью лодки')


class Logistics(ABC):
    """Класс логистики, основная роль которого - доставить заказ до пункта назначения.

    Объявляет фабричный метод создания транспорта. Подклассы переопределят этот метод,
    реализация которых будет возвращать конкретный транспорт.
    """

    @abstractmethod
    def create_transport(self) -> Transport:
        """Фабричный метод. Может содержать реализацию по умолчанию."""
        pass

    def plan_delivery(self):
        """Бизнес логика доставки.

        Стоит отметить, что основная цель данного класса не заключечается в создании продуктов (транспорта).
        """
        print('Поступила доставка!')

        # Вызываем фабричный метод, чтобы получить продукт
        transport = self.create_transport()

        # Далее, работаем с этим продуктом (транспорт). Мы не знаем какой это транспорт на самом деле.
        # Нам и не нужно знать. Главное, что объект этого транспорта - реализует нужный нам интерфейс.
        # А как устроена его реализация - нам не важно!
        transport.deliver()

        print('Заказ успешно доставлен!')


# Конкретные реализации класса Логистики. Реализуют фабричный метод, чтобы изменить тип
# результирующего продукта.

class RoadLogistics(Logistics):
    """
    Стоит обратить внимание, что сигнатура метода по-прежнему использует тип
    абстрактного продукта, хотя фактически из метода возвращается конкретный
    продукт. Таким образом, данный класс логистики может оставаться независимым от конкретных
    классов продуктов (транспортов), то есть, можно заменить транспорт, например, на поезд.
    """

    def create_transport(self) -> Transport:
        return Truck()


class SeaLogistics(Logistics):
    def create_transport(self) -> Transport:
        return Ship()


def client_code(logistics: Logistics):
    """
    Клиентский код работает с экземпляром конкретной логистики, хотя и через
    его базовый интерфейс. Пока клиент продолжает работать с логистикой через
    базовый интерфейс, вы можете передать ему любой подкласс логистики.
    """
    logistics.plan_delivery()


if __name__ == '__main__':
    client_code(RoadLogistics())
    client_code(SeaLogistics())
